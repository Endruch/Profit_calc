package com.example.profitcalc

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.example.profitcalc.ui.theme.ProfitCalcTheme

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            ProfitCalcTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = Color(0xFF0F172A) // –¢–µ–º–Ω—ã–π —Ñ–æ–Ω
                ) {
                    TradingProfitCalculator()
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TradingProfitCalculator() {
    var entryPrice by remember { mutableStateOf("") }
    var exitPrice by remember { mutableStateOf("") }
    var tradeVolume by remember { mutableStateOf("") }
    var positionType by remember { mutableStateOf("long") }
    var commissionRate by remember { mutableStateOf("0.1") }

    val scrollState = rememberScrollState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(scrollState)
            .padding(16.dp)
    ) {
        // –ó–∞–≥–æ–ª–æ–≤–æ–∫
        Text(
            text = "üìà –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ø—Ä–æ—Ñ–∏—Ç–∞",
            color = Color.White,
            fontSize = 24.sp,
            fontWeight = FontWeight.Bold,
            modifier = Modifier.padding(bottom = 24.dp),
            textAlign = TextAlign.Center
        )

        // –í—ã–±–æ—Ä —Ç–∏–ø–∞ –ø–æ–∑–∏—Ü–∏–∏
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 16.dp),
            colors = CardDefaults.cardColors(
                containerColor = Color(0xFF1E293B)
            ),
            shape = RoundedCornerShape(12.dp)
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = "–¢–∏–ø –ø–æ–∑–∏—Ü–∏–∏",
                    color = Color(0xFFD1D5DB),
                    fontSize = 14.sp,
                    fontWeight = FontWeight.Medium,
                    modifier = Modifier.padding(bottom = 12.dp)
                )

                Row(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    // LONG –∫–Ω–æ–ø–∫–∞
                    Card(
                        modifier = Modifier
                            .weight(1f)
                            .selectable(
                                selected = positionType == "long",
                                onClick = { positionType = "long" }
                            ),
                        colors = CardDefaults.cardColors(
                            containerColor = if (positionType == "long")
                                Color(0xFF16A34A) else Color(0xFF374151)
                        ),
                        shape = RoundedCornerShape(8.dp)
                    ) {
                        Box(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(12.dp),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(
                                text = "LONG ‚Üó",
                                color = Color.White,
                                fontWeight = FontWeight.Medium
                            )
                        }
                    }

                    Spacer(modifier = Modifier.width(8.dp))

                    // SHORT –∫–Ω–æ–ø–∫–∞
                    Card(
                        modifier = Modifier
                            .weight(1f)
                            .selectable(
                                selected = positionType == "short",
                                onClick = { positionType = "short" }
                            ),
                        colors = CardDefaults.cardColors(
                            containerColor = if (positionType == "short")
                                Color(0xFFDC2626) else Color(0xFF374151)
                        ),
                        shape = RoundedCornerShape(8.dp)
                    ) {
                        Box(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(12.dp),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(
                                text = "SHORT ‚Üò",
                                color = Color.White,
                                fontWeight = FontWeight.Medium
                            )
                        }
                    }
                }
            }
        }

        // –¶–µ–Ω—ã
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 16.dp)
        ) {
            PriceInputCard(
                label = "–¶–µ–Ω–∞ –≤—Ö–æ–¥–∞ ($)",
                value = entryPrice,
                onValueChange = { entryPrice = it },
                modifier = Modifier.weight(1f)
            )

            Spacer(modifier = Modifier.width(8.dp))

            PriceInputCard(
                label = "–¶–µ–Ω–∞ –≤—ã—Ö–æ–¥–∞ ($)",
                value = exitPrice,
                onValueChange = { exitPrice = it },
                modifier = Modifier.weight(1f)
            )
        }

        // –û–±—ä–µ–º —Å–¥–µ–ª–∫–∏
        VolumeInputSection(
            volume = tradeVolume,
            onVolumeChange = { tradeVolume = it }
        )

        // –ö–æ–º–∏—Å—Å–∏—è –±–∏—Ä–∂–∏
        CommissionInputCard(
            value = commissionRate,
            onValueChange = { commissionRate = it }
        )

        // –†–µ–∑—É–ª—å—Ç–∞—Ç—ã
        val result = calculateProfit(entryPrice, exitPrice, tradeVolume, positionType, commissionRate)
        result?.let {
            ResultsCard(result = it, positionType = positionType)
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PriceInputCard(
    label: String,
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier,
        colors = CardDefaults.cardColors(
            containerColor = Color(0xFF1E293B)
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = label,
                color = Color(0xFFD1D5DB),
                fontSize = 12.sp,
                fontWeight = FontWeight.Medium,
                modifier = Modifier.padding(bottom = 8.dp)
            )

            OutlinedTextField(
                value = value,
                onValueChange = onValueChange,
                placeholder = { Text("0.00", color = Color(0xFF6B7280)) },
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedTextColor = Color.White,
                    unfocusedTextColor = Color.White,
                    focusedBorderColor = Color(0xFF3B82F6),
                    unfocusedBorderColor = Color(0xFF4B5563)
                ),
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CommissionInputCard(
    value: String,
    onValueChange: (String) -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(bottom = 16.dp),
        colors = CardDefaults.cardColors(
            containerColor = Color(0xFF1E293B)
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "–ö–æ–º–∏—Å—Å–∏—è –±–∏—Ä–∂–∏ (%)",
                color = Color(0xFFD1D5DB),
                fontSize = 12.sp,
                fontWeight = FontWeight.Medium,
                modifier = Modifier.padding(bottom = 8.dp)
            )

            OutlinedTextField(
                value = value,
                onValueChange = onValueChange,
                placeholder = { Text("0.1", color = Color(0xFF6B7280)) },
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedTextColor = Color.White,
                    unfocusedTextColor = Color.White,
                    focusedBorderColor = Color(0xFF3B82F6),
                    unfocusedBorderColor = Color(0xFF4B5563)
                ),
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

@Composable
fun VolumeInputSection(
    volume: String,
    onVolumeChange: (String) -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(bottom = 16.dp),
        colors = CardDefaults.cardColors(
            containerColor = Color(0xFF1E293B)
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "–û–±—ä–µ–º —Å–¥–µ–ª–∫–∏",
                color = Color.White,
                fontSize = 16.sp,
                fontWeight = FontWeight.SemiBold,
                modifier = Modifier.padding(bottom = 12.dp)
            )

            VolumeInput("–°—É–º–º–∞ ($)", volume, onVolumeChange)
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun VolumeInput(
    label: String,
    value: String,
    onValueChange: (String) -> Unit
) {
    Column {
        Text(
            text = label,
            color = Color(0xFFD1D5DB),
            fontSize = 12.sp,
            fontWeight = FontWeight.Medium,
            modifier = Modifier.padding(bottom = 4.dp)
        )

        OutlinedTextField(
            value = value,
            onValueChange = onValueChange,
            placeholder = { Text("0", color = Color(0xFF6B7280)) },
            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
            colors = OutlinedTextFieldDefaults.colors(
                focusedTextColor = Color.White,
                unfocusedTextColor = Color.White,
                focusedBorderColor = Color(0xFF3B82F6),
                unfocusedBorderColor = Color(0xFF4B5563)
            ),
            modifier = Modifier.fillMaxWidth()
        )
    }
}

@Composable
fun ResultsCard(result: ProfitResult, positionType: String) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(bottom = 16.dp),
        colors = CardDefaults.cardColors(
            containerColor = Color(0xFF1E293B)
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—Å—á–µ—Ç–∞",
                color = Color.White,
                fontSize = 16.sp,
                fontWeight = FontWeight.SemiBold,
                modifier = Modifier.padding(bottom = 16.dp)
            )

            // –û—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏
            Column {
                ResultRow("–°—É–º–º–∞ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏:", "$${String.format("%.2f", result.totalInvestment)}")
                ResultRow("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –µ–¥–∏–Ω–∏—Ü:", String.format("%.6f", result.totalUnits))

                HorizontalDivider(
                    color = Color(0xFF374151),
                    modifier = Modifier.padding(vertical = 8.dp)
                )

                ResultRow("–ö–æ–º–∏—Å—Å–∏—è –∑–∞ –≤—Ö–æ–¥:", "-$${String.format("%.2f", result.entryFee)}", isNegative = true)
                ResultRow("–ö–æ–º–∏—Å—Å–∏—è –∑–∞ –≤—ã—Ö–æ–¥:", "-$${String.format("%.2f", result.exitFee)}", isNegative = true)
                ResultRow("–û–±—â–∏–µ –∫–æ–º–∏—Å—Å–∏–∏:", "-$${String.format("%.2f", result.totalFees)}", isNegative = true)

                HorizontalDivider(
                    color = Color(0xFF374151),
                    modifier = Modifier.padding(vertical = 8.dp)
                )

                ResultRow("–í–∞–ª–æ–≤–∞—è –ø—Ä–∏–±—ã–ª—å:", "$${String.format("%.2f", result.grossProfit)}",
                    isNegative = result.grossProfit < 0)

                HorizontalDivider(
                    color = Color(0xFF374151),
                    modifier = Modifier.padding(vertical = 8.dp)
                )

                // –ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 4.dp),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "–ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å:",
                        color = Color(0xFFD1D5DB),
                        fontSize = 16.sp,
                        fontWeight = FontWeight.SemiBold
                    )
                    Text(
                        text = "${if (result.netProfit >= 0) "‚Üó" else "‚Üò"} $${String.format("%.2f", result.netProfit)}",
                        color = if (result.netProfit >= 0) Color(0xFF10B981) else Color(0xFFEF4444),
                        fontWeight = FontWeight.Bold,
                        fontSize = 16.sp
                    )
                }

                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 4.dp),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "–ü—Ä–∏–±—ã–ª—å %:",
                        color = Color(0xFFD1D5DB),
                        fontSize = 16.sp,
                        fontWeight = FontWeight.SemiBold
                    )
                    Text(
                        text = "${if (result.profitPercentage >= 0) "‚Üó" else "‚Üò"} ${String.format("%.2f", result.profitPercentage)}%",
                        color = if (result.profitPercentage >= 0) Color(0xFF10B981) else Color(0xFFEF4444),
                        fontWeight = FontWeight.Bold,
                        fontSize = 16.sp
                    )
                }
            }

            // –°—Ç–∞—Ç—É—Å —Å–¥–µ–ª–∫–∏
            Spacer(modifier = Modifier.height(12.dp))
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = when {
                        result.netProfit > 0 -> Color(0xFF065F46)
                        result.netProfit < 0 -> Color(0xFF7F1D1D)
                        else -> Color(0xFF374151)
                    }
                ),
                shape = RoundedCornerShape(8.dp)
            ) {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(12.dp),
                    contentAlignment = Alignment.Center
                ) {
                    val statusText = when {
                        result.netProfit > 0 -> "‚úÖ –ü—Ä–∏–±—ã–ª—å–Ω–∞—è —Å–¥–µ–ª–∫–∞"
                        result.netProfit < 0 -> "‚ùå –£–±—ã—Ç–æ—á–Ω–∞—è —Å–¥–µ–ª–∫–∞"
                        else -> "‚öñÔ∏è –ë–µ–∑—É–±—ã—Ç–æ—á–Ω–∞—è —Å–¥–µ–ª–∫–∞"
                    }
                    Text(
                        text = statusText,
                        color = Color.White,
                        fontWeight = FontWeight.Medium
                    )
                }
            }
        }
    }
}

@Composable
fun ResultRow(
    label: String,
    value: String,
    isNegative: Boolean = false
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(
            text = label,
            color = Color(0xFFD1D5DB),
            fontSize = 14.sp
        )
        Text(
            text = value,
            color = if (isNegative) Color(0xFFEF4444) else Color.White,
            fontWeight = FontWeight.Medium,
            fontSize = 14.sp
        )
    }
}

data class ProfitResult(
    val totalInvestment: Double,
    val totalUnits: Double,
    val grossProfit: Double,
    val netProfit: Double,
    val profitPercentage: Double,
    val entryFee: Double,
    val exitFee: Double,
    val totalFees: Double
)

fun calculateProfit(
    entryPrice: String,
    exitPrice: String,
    tradeVolume: String,
    positionType: String,
    commissionRate: String
): ProfitResult? {
    val entry = entryPrice.toDoubleOrNull() ?: return null
    val exit = exitPrice.toDoubleOrNull() ?: return null
    val volume = tradeVolume.toDoubleOrNull() ?: return null
    val commission = commissionRate.toDoubleOrNull() ?: return null

    if (entry <= 0.0 || exit <= 0.0 || volume <= 0.0) return null

    // –ö–æ–º–∏—Å—Å–∏—è –≤ –¥–µ—Å—è—Ç–∏—á–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 0.1% = 0.001)
    val feeRate = commission / 100.0

    return if (positionType == "long") {
        calculateLongPosition(entry, exit, volume, feeRate)
    } else {
        calculateShortPosition(entry, exit, volume, feeRate)
    }
}

private fun calculateLongPosition(
    entryPrice: Double,
    exitPrice: Double,
    volume: Double,
    feeRate: Double
): ProfitResult {
    // LONG –ø–æ–∑–∏—Ü–∏—è: –ø–æ–∫—É–ø–∞–µ–º –∞–∫—Ç–∏–≤ –ø–æ —Ü–µ–Ω–µ –≤—Ö–æ–¥–∞, –ø—Ä–æ–¥–∞–µ–º –ø–æ —Ü–µ–Ω–µ –≤—ã—Ö–æ–¥–∞

    // –ö–æ–º–∏—Å—Å–∏—è –∑–∞ –ø–æ–∫—É–ø–∫—É
    val entryFee = volume * feeRate

    // –°—É–º–º–∞ –ø–æ—Å–ª–µ –∫–æ–º–∏—Å—Å–∏–∏, –¥–æ—Å—Ç—É–ø–Ω–∞—è –¥–ª—è –ø–æ–∫—É–ø–∫–∏ –∞–∫—Ç–∏–≤–∞
    val effectiveVolume = volume - entryFee

    // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –µ–¥–∏–Ω–∏—Ü –∞–∫—Ç–∏–≤–∞, –∫–æ—Ç–æ—Ä–æ–µ –º—ã –º–æ–∂–µ–º –∫—É–ø–∏—Ç—å
    val units = effectiveVolume / entryPrice

    // –í–∞–ª–æ–≤–∞—è —Å—É–º–º–∞ –æ—Ç –ø—Ä–æ–¥–∞–∂–∏
    val grossSaleAmount = units * exitPrice

    // –ö–æ–º–∏—Å—Å–∏—è –∑–∞ –ø—Ä–æ–¥–∞–∂—É
    val exitFee = grossSaleAmount * feeRate

    // –ß–∏—Å—Ç–∞—è —Å—É–º–º–∞ –ø–æ—Å–ª–µ –ø—Ä–æ–¥–∞–∂–∏
    val netSaleAmount = grossSaleAmount - exitFee

    // –í–∞–ª–æ–≤–∞—è –ø—Ä–∏–±—ã–ª—å (–±–µ–∑ —É—á–µ—Ç–∞ –∫–æ–º–∏—Å—Å–∏–π)
    val grossProfit = grossSaleAmount - effectiveVolume

    // –ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å (—Å —É—á–µ—Ç–æ–º –≤—Å–µ—Ö –∫–æ–º–∏—Å—Å–∏–π)
    val netProfit = netSaleAmount - volume

    // –ü—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∏–±—ã–ª–∏
    val profitPercentage = (netProfit / volume) * 100

    val totalFees = entryFee + exitFee

    return ProfitResult(
        totalInvestment = volume,
        totalUnits = units,
        grossProfit = grossProfit,
        netProfit = netProfit,
        profitPercentage = profitPercentage,
        entryFee = entryFee,
        exitFee = exitFee,
        totalFees = totalFees
    )
}

private fun calculateShortPosition(
    entryPrice: Double,
    exitPrice: Double,
    volume: Double,
    feeRate: Double
): ProfitResult {
    // SHORT –ø–æ–∑–∏—Ü–∏—è: –ø—Ä–æ–¥–∞–µ–º –∞–∫—Ç–∏–≤ –ø–æ —Ü–µ–Ω–µ –≤—Ö–æ–¥–∞, –ø–æ–∫—É–ø–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ –ø–æ —Ü–µ–Ω–µ –≤—ã—Ö–æ–¥–∞

    // –ö–æ–º–∏—Å—Å–∏—è –∑–∞ –æ—Ç–∫—Ä—ã—Ç–∏–µ short –ø–æ–∑–∏—Ü–∏–∏ (–ø—Ä–æ–¥–∞–∂—É)
    val entryFee = volume * feeRate

    // –°—É–º–º–∞ –ø–æ—Å–ª–µ –∫–æ–º–∏—Å—Å–∏–∏
    val effectiveVolume = volume - entryFee

    // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –µ–¥–∏–Ω–∏—Ü –∞–∫—Ç–∏–≤–∞ –≤ short –ø–æ–∑–∏—Ü–∏–∏
    val units = effectiveVolume / entryPrice

    // –°—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ–∫—É–ø–∫–∏ –∞–∫—Ç–∏–≤–∞ –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏
    val buybackCost = units * exitPrice

    // –ö–æ–º–∏—Å—Å–∏—è –∑–∞ –ø–æ–∫—É–ø–∫—É (–∑–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏)
    val exitFee = buybackCost * feeRate

    // –û–±—â–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏
    val totalBuybackCost = buybackCost + exitFee

    // –í–∞–ª–æ–≤–∞—è –ø—Ä–∏–±—ã–ª—å (—Ä–∞–∑–Ω–∏—Ü–∞ –≤ —Ü–µ–Ω–µ –±–µ–∑ —É—á–µ—Ç–∞ –∫–æ–º–∏—Å—Å–∏–π)
    val grossProfit = effectiveVolume - buybackCost

    // –ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å = –∏–∑–Ω–∞—á–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ + (–¥–æ—Ö–æ–¥ –æ—Ç short - —Å—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞–∫—Ä—ã—Ç–∏—è) - –∏–∑–Ω–∞—á–∞–ª—å–Ω–∞—è —Å—É–º–º–∞
    // –£–ø—Ä–æ—â–∞–µ—Ç—Å—è –¥–æ: –¥–æ—Ö–æ–¥ –æ—Ç short - —Å—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞–∫—Ä—ã—Ç–∏—è - –∫–æ–º–∏—Å—Å–∏–∏
    val netProfit = effectiveVolume - totalBuybackCost

    // –ü—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∏–±—ã–ª–∏
    val profitPercentage = (netProfit / volume) * 100

    val totalFees = entryFee + exitFee

    return ProfitResult(
        totalInvestment = volume,
        totalUnits = units,
        grossProfit = grossProfit,
        netProfit = netProfit,
        profitPercentage = profitPercentage,
        entryFee = entryFee,
        exitFee = exitFee,
        totalFees = totalFees
    )
}

@Preview(showBackground = true)
@Composable
fun TradingProfitCalculatorPreview() {
    ProfitCalcTheme {
        Surface(
            modifier = Modifier.fillMaxSize(),
            color = Color(0xFF0F172A)
        ) {
            TradingProfitCalculator()
        }
    }
}
